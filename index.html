<!DOCTYPE html>
<html lang="en">
<head>

<title>VM Map</title>
<meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1">

<link rel='stylesheet' href='css/3rd-party/maplibre-gl.css' />
<link rel="stylesheet" href="css/style.css">

<script src="provideStyleImage.js"></script>
<script src="addStudyArea.js"></script>

<!-- 3rd party scripts -->
<!-- Printing and export functionality -->
<script src="js/3rd-party/html2canvas.min.js"></script> 
<script src="js/3rd-party/html-to-image.js"></script>
<script src="js/3rd-party/jspdf.umd.min.js"></script>
<script src="js/3rd-party/FileSaver.min.js"></script>

<!-- Map and Geometry -->
<script src='js/3rd-party/maplibre-gl.js'></script>
<script src="js/3rd-party/turf.min.js"></script>
<script src="js/3rd-party/turf-reverse.js"></script>

<!-- JQuery -->
<script src="js/3rd-party/jquery.min.js"></script>
<script src="js/3rd-party/jquery-ui.min.js"></script>

<style>

</style>
</head>
<body>

<script>


  // rest of your code here

</script>





	<div class="container" id="protected" style="display:none">
	  <div class="map-container">
		  <div class="main-window" id='map'>
		  <div id="map-buttons-container" style="display: flex; justify-content: space-between;">
			  <button id="button-fit" class = "button-fit">Ganzes Gebiet anzeigen</button>

				<select id="export" class="dropdownSelect">
					<option hidden disabled selected value> Exportieren </option>
					<option value="pdf">PDF</option>
					<option value="png">PNG</option>
      			</select>

			  <select id="styles" class="dropdownSelect">
				<option value="basemap-de-style-a06ceb84.json">Karte</option>
				<option value="https://raw.githubusercontent.com/go2garret/maps/main/src/assets/json/arcgis_hybrid.json">Satellit</option>
				<option value="https://sgx.geodatenzentrum.de/gdz_basemapde_vektor/styles/bm_web_top.json">Topographisch</option>
				<option value="https://sgx.geodatenzentrum.de/gdz_basemapde_vektor/styles/bm_web_gry.json">Graustufen</option>
				
			  </select>
		  </div>

		  <div class="legend">
			<span class="weitere-layer" style="cursor: pointer;">Legende und weitere Layer</span>
			<div class="collapsible">
<!--			<div class="legend-item">
			  <input type="checkbox" id="traffic" value="traffic" onchange="switchlayer(['traffic'], 'traffic')" />
			  <label for="traffic">Verkehrslage</label>
			</div>
			<div class="legend-sub-group">
			  <div class="legend-sub-item">
				<input type="radio" name="traffic-flow" id="traffic-flow-current" value="traffic-flow-current" onchange="switchlayer(['traffic-flow-current'], 'traffic-flow-current')" checked/>
				<label for="traffic-flow-current">Aktuell</label>
			  </div>
 			  <div class="legend-sub-item">
				<input type="radio" name="traffic-flow" id="traffic-flow-morning" value="traffic-flow-morning" onchange="switchlayer(['traffic-flow-morning'], 'traffic-flow-current')" />
				<label for="traffic-flow-morning">Morgens</label>
			  </div>
			  <div class="legend-sub-item">
				<input type="radio" name="traffic-flow" id="traffic-flow-noon" value="traffic-flow-noon" onchange="switchlayer(['traffic-flow-noon'], 'traffic-flow-noon')" />
				<label for="traffic-flow-noon">Mittags</label>
			  </div>
			  <div class="legend-sub-item">
				<input type="radio" name="traffic-flow" id="traffic-flow-evening" value="traffic-flow-evening" onchange="switchlayer(['traffic-flow-evening'], 'traffic-flow-evening')" />
				<label for="traffic-flow-evening">Abends</label>
			  </div>
			  <div class="legend-sub-item">
				<input type="radio" name="traffic-flow" id="traffic-flow-night" value="traffic-flow-night" onchange="switchlayer(['traffic-flow-night'], 'traffic-flow-night')" />
				<label for="traffic-flow-night">Nachts</label>
			  </div>
			</div> -->
			<div class="legend-item">
				<input type="checkbox" id="landkreise" value="landkreise" onchange="switchlayer(['landkreise-fill', 'landkreise-line'], 'landkreise')" />
				<label for="landkreise">Landkreise</label>
			</div>
			<div class="legend-item">
				<input type="checkbox" id="untersuchungsgebiet" value="untersuchungsgebiet" onchange="switchlayer(['untersuchungsgebiet-line'], 'untersuchungsgebiet')" />
				<label for="untersuchungsgebiet">Untersuchungsgebiet</label>
			</div>
			<div id ="gemeinden"></br>Gemeinden</div>
			<div></br>Strategische Netze</div>
			<div class="legend-item">
				<input type="checkbox" id="strategisches-netz-pt" value="strategisches-netz-pt" onchange="switchlayer(['bus-lines', 'bus-labels', 'zug-lines', 'zug-labels', 'stadtbahn-lines', 'stadtbahn-labels', 'haltestellen-fill', 'haltestellen-outlines', 'layer-Mobilitätsstationen'], 'strategisches-netz-pt')" />
				<label for="strategisches-netz-pt">ÖV</label>
			</div>
			<div class="legend-item">
				<input type="checkbox" id="strategisches-netz-rad" value="strategisches-netz-rad" onchange="switchlayer(['RadNETZBW-layer', 'RadNETZKreis-layer', 'RadNETZKom-layer', 'RadOSM-layer',
																														 'bikeSharingStations', 'Scooter-Leihstationen',
																														 'Fahrradabstellanlagen'], 'strategisches-netz-rad')" />
				<label for="strategisches-netz-rad">Rad</label>
			</div>
			<div class="legend-item">
				<input type="checkbox" id="strategisches-netz-miv" value="strategisches-netz-miv" onchange="switchlayer(['K-line', 'K-name-label', 'K-direction-arrow', 'L-line', 'L-name-label', 'L-direction-arrow', 'B-line', 'B-direction-arrow', 'B-name-label', 'node-label', 'node-symbol', 'BAB-line', 'BAB-name-label', 'km-label', 'km-symbol', 'parking-sites', 'dwista-layer', 'lsa-layer', 'lsa-osm-layer', 'layer-car-sharing'], 'strategisches-netz-miv')" />
				<label for="strategisches-netz-miv">MIV</label>
			</div>

			<div></br>Sonstiges</div>
			<div class="legend-item">
				<input type="checkbox" id="accidents" value="accidents" onchange="switchlayer(['accidents-layer'], 'accidents')" />
				<label for="accidents">Unfälle</label>
			</div>
<!-- 			<div class="legend-item">
				<input type="checkbox" id="noise" value="noise" onchange="switchlayer(['noise-layer'], 'noise')" />
				<label for="noise">Lärm</label>
			</div> -->
			<div id="legend-bottlenecks"></br>Problemstellen</div>
			<div id="legend-measures"></br>Maßnahmen</div>

		</div>
	</div>

		  </div>
	  </div>
	  <div id="sidebar" class="sidebar">
		  <div class="tab-container">
			  <div class="tab" id="tab-bottlenecks">Problemstellen
				<input type="checkbox" id="visibility-checkbox" style="margin-left: auto;" autocomplete="off">
			  </div>
			  <div class="tab" id="tab-measures"style="border-left: none">Ma&szlig;nahmen
				<input type="checkbox" id="visibility-checkbox" style="margin-left: auto;" autocomplete="off">
			  </div>
			  <div class="tab active" id="tab-strategies"style="border-left: none">Strategien
				<input type="checkbox" id="visibility-checkbox" style="margin-left: auto;" autocomplete="off">
			  </div>
		  </div> 
		  <div class="tab-body" id="measures"></div>
		  <div class="tab-body" id="bottlenecks"></div>
		  <div class="tab-body" id="strategies"></div>

		  <div class="info-links" id="InfoLinks">
			<div style="display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
			<a href="info.html" style="color: inherit" target="_blank">Info</a>
			<a href="privacy.html" style="color: inherit" target="_blank">Datenschutz</a>
			<a href="https://okari.com/impressum/" style="color: inherit" target="_blank">Impressum</a> 
			</div>
		  </div>

	  </div>  
	</div>
  
	<template id="template">
		<div class="sidebar-entry">
		<header>
			<div class="headline">Überschrift</div>		 
		</header>
		<div class="image-container"><img class="sidebar-image" loading="lazy" src=""  alt = ""></div>
		<div class="description" lang="de">Beschreibung</div>
		<!-- <div class="tartlink"><a class="cartlink" href="">In den Warenkorb</a></div> -->
		</div>
	</template>
	
	<template id="category-group-template">
		<div class="category-group" data-category="Some Category">
			<div class="category" style="font-weight: bold;">
				<div id="category-text"></div>
				<input type="checkbox" id="visibility-checkbox" style="margin-left: auto;">
			</div>
		</div>
	</template>

<script type="module">

    const password = "rvm";
    const entered = prompt("Passwort:");
    if (entered !== password) {
      document.body.innerHTML = "Zugriff verweigert.";
	  throw new Error("Wrong password");
    } else {
      document.getElementById("protected").removeAttribute("style");

    };

	import { addStrategicNetworkBike } from "./addStrategicNetworkBike.js";
	import { addStrategicNetworkPT } from "./addStrategicNetworkPT.js";
	import { addStrategicNetworkStreets } from "./addStrategicNetworkStreets.js";
	import { addAccidents } from "./addAccidents.js";
	import { addMunicipalities } from "./addMunicipalities.js";
	import { addBottlenecks } from "./js/addBottlenecks.js";
	import { filterBottlenecks } from "./js/filterBottlenecks.js";
	import { addMeasures } from "./js/addMeasures.js";
	import { scrollSidebarToEntry } from "./js/scrollSidebarToEntry.js";
	import { addStrategies } from "./js/addStrategies.js";
	// import { addNoise } from "./addNoise.js";

	const locations = {
	"default":    "lat=49.20020&lng=9.17364&zoom=9.67&pitch=0&bearing=0",
	"Strategie1": "lat=49.17720&lng=9.3455&zoom=11.57&pitch=23&bearing=89",
	"Strategie2": "lat=49.21966&lng=9.26299&zoom=11.81",
	"Strategie3": "lat=49.11987&lng=9.15894&zoom=13.05",
	"Strategie4": "lat=49.18621&lng=9.20577&zoom=12.19"
	};

	// Start with default
	const baseParams = new URLSearchParams(locations.default);

	// Overwrite with Strategie if specified
	const urlParams = new URLSearchParams(window.location.search);
	const locKey = urlParams.get('location');
	if (locKey && locations[locKey]) {
	const stratParams = new URLSearchParams(locations[locKey]);
	for (const [key, value] of stratParams) {
		baseParams.set(key, value);
	}
	}

	// Overwrite with any explicit URL parameters
	for (const [key, value] of urlParams) {
		if (key !== 'location') {
			const num = parseFloat(value);
			// Only overwrite if it's a valid number
			if (!isNaN(num)) {
			baseParams.set(key, value);
			}
		}
	}

	// Parse final parameters
	const lat     = parseFloat(baseParams.get('lat'));
	const lng     = parseFloat(baseParams.get('lng'));
	const zoom    = parseFloat(baseParams.get('zoom'));
	const pitch   = parseFloat(baseParams.get('pitch'));
	const bearing = parseFloat(baseParams.get('bearing'));

	// Initialize map
	const map = new maplibregl.Map({
	container: 'map',
	style: 'basemap-de-style-a06ceb84.json',
	center: [lng, lat],
	zoom: zoom,
	bearing: bearing,
	pitch: pitch,
	maxZoom: 18,
	canvasContextAttributes: { preserveDrawingBuffer: true }
	});
	map.addControl(new maplibregl.NavigationControl({visualizePitch: true}), 'bottom-left');

	
	const data_bottlenecks = await (await fetch('data/geojson/problemstellen.geojson')).json();
	let data_measures = await (await fetch('data/geojson/massnahmen.geojson')).json();
	const data_streets = await (await fetch('data/geojson/strategic-networks/iv/BLK.geojson')).json();

	const img_route = 'data/images/'
	const icon_route = 'data/icons/'

	window.cursorOnMarker = false;

	document.getElementById('button-fit').addEventListener('click', () => {
		// map.fitBounds(bbox, { duration: 1000, pitch: 0, padding: 64, });
		map.fitBounds([
			[8.82088, 49.37708],
			[9.52641, 49.02268]
        ], { duration: 1000, padding: 32 , pitch: 0});
	});

    map.on('load', async () => {

		prepareUI();
		// loadMeasures(); // Adds Measures markers to the map. Adds Category groups to the sidebar. Adds clicking functionality to the markers. Adds eventListeners to the markers. Adds Sidebar entries to the sidebar measures tab. Only has to be called once.
		provideStyleImage(map);
		addStrategicNetworkPT(map);
		addStrategicNetworkBike(map);
		addStudyArea(map); // Adds Untersuchungsgebiet layer
		addStrategicNetworkStreets(map);
		addAccidents(map);
		// addNoise(map);
		addMunicipalities(map); // Adds Communities layer
		addCounties(); // Adds Counties Layer
		addTraffic(); // Adds realtime traffic layer to map.
		await addBottlenecks(map, data_bottlenecks, img_route); // Adds bottlenecks layer to the map.
		await addMeasures(map, data_measures, img_route, icon_route); // Adds measures layer to the map.
		await addStrategies(map, data_bottlenecks, data_measures); // Adds strategies to the sidebar. Doesn't touch the map
		handleMapClicks();
		handleHovering();
		handlePointer();

		console.log("load called");

		let bounds = map.getBounds();
		console.log('Map bounds (current view):', bounds);
		
	});

	map.on('style.load', async () => {
		
		await addTraffic();

		//await addOtherLayers();

		addStrategicNetworkPT(map);
		addStrategicNetworkBike(map);
		addStrategicNetworkStreets(map);
		addStudyArea(map);
		addAccidents(map);
		// addNoise(map);
		addMunicipalities(map);
		addCounties();
		addBottlenecks(map, data_bottlenecks, img_route);
		console.log("style.load called");

	});

	map.on('moveend', () => {
		const center = map.getCenter();
		const zoom = map.getZoom();
		const params = new URLSearchParams({
			lat: center.lat.toFixed(5),
			lng: center.lng.toFixed(5),
			zoom: map.getZoom().toFixed(2),
			// bearing: map.getBearing().toFixed(1),
			// pitch: map.getPitch().toFixed(1)
		});
		history.replaceState({}, '', `${location.pathname}?${params}`);
	});

	async function addCounties()
	{
		map.addSource('landkreise', {
            type: 'geojson',
            // Use a URL for the value for the `data` property.
            data: 'data/geojson/landkreise.geojson',
			generateId: true // This ensures that all features have unique IDs
        });

		map.addLayer({
            'id': 'landkreise-fill',
            'type': 'fill',
            'source': 'landkreise',
            'layout': {
				'visibility': 'none',
			},
            'paint': {
                'fill-color': '#0000AA',
                'fill-opacity': [
                    'case',
                    ['boolean', ['feature-state', 'hover'], false],
                    0.1,
                    0.0
                ]
            }
        });

        map.addLayer({
            'id': 'landkreise-line',
            'type': 'line',
            'source': 'landkreise',
			'layout': {
				'visibility': 'none',
			},
            'paint': {
                'line-color': '#0000AA',
                'line-width': 1.25,
				'line-dasharray': [3,3]
            }
        });

		console.log("added landkreise...")
	}

	async function addTraffic(){
		console.log("Adding layer traffic")

		map.addSource('traffic-flow-source', {
            type: 'vector',
            tiles: [
            atob('aHR0cHM6Ly90cmFmZmljLnZlY3Rvci5oZXJlYXBpLmNvbS92Mi90cmFmZmljdGlsZXMvZmxvdy9tYy97en0ve3h9L3t5fS9vbXY/YXBpS2V5PU9OTkEwVlVwVXhBYXhfS1BtREhUNF9pWVFlbUtnaXRMX01lV1Y2eHBBVkE=') ,
            ],
        });

		console.log($("#traffic").prop("checked"));

		let visibility = "none";
		if($("#traffic").prop("checked"))
			visibility = "visible"
		map.addLayer(
            {
                "id": "traffic",
                "type": "line",
                "source": "traffic-flow-source",
				"source-layer": "traffic_flow", 
                "paint": {
                  "line-color": [
                    "case",
                    ["<", ["get", "congestion"], 0.25], "#00FF00",
                    ["<", ["get", "congestion"], 0.5], "#FFFF00",
                    ["<", ["get", "congestion"], 0.75], "#FFA500",
                    "#FF0000"
                  ],
                  "line-width": 3,
				  "line-offset" : 2,
                },
				"layout" : {
					"visibility": visibility,
				}
            }
        );
	}


	

	function prepareUI(){
		console.log("preparing UI");
		$(".tab").click(openTab); // adds the Tab clicking functionality
		$("#bottlenecks").toggle(); // hides the bottlenecks div in the sidebar.
		// $("#strategies").toggle(); // hides the strategies div in the sidebar.
		$("#measures").toggle(); // hides the measures div in the sidebar.

		$("#tab-bottlenecks > #visibility-checkbox").on('click',  (event) => {		
			if($(event.target).prop('checked'))
			{
				if ($("#tab-strategies > #visibility-checkbox").prop('checked'))
					$("#tab-strategies > #visibility-checkbox").click()
			}
			// event.stopPropagation();
			toggleBottleneckLayer();
		});

		$("#tab-measures > #visibility-checkbox").on('click',  (event) => {
			if($(event.target).prop('checked'))
			{
				if ($("#tab-strategies > #visibility-checkbox").prop('checked'))
					$("#tab-strategies > #visibility-checkbox").click()
			}

			// event.stopPropagation();
			toggleMeasuresLayer();
		}); 

		$("#tab-strategies > #visibility-checkbox").on('click',  (event) => {
			// deactivate tab measures and bottlenecks if turned on
			if($(event.target).prop('checked'))
			{
				if ($("#tab-bottlenecks > #visibility-checkbox").prop('checked'))
					$("#tab-bottlenecks > #visibility-checkbox").click()
				if ($("#tab-measures > #visibility-checkbox").prop('checked'))
					$("#tab-measures > #visibility-checkbox").click()
			}
			// event.stopPropagation();
			toggleStrategiesLayer();

		}); 

		// initiate styles dropdown
		document.getElementById("styles").selectedIndex = 0;
		document.getElementById("styles").addEventListener("change", function (event) {
			const styleId = event.target.value;
			map.setStyle(styleId, {diff: false});
			if(styleId == 'https://raw.githubusercontent.com/go2garret/maps/main/src/assets/json/arcgis_hybrid.json')
				map.setMaxZoom(15.99)
			else
				map.setMaxZoom(18)

				var checkboxes = document.querySelectorAll('.legend input[type="checkbox"]');

				// Loop through all checkboxes and uncheck them
				checkboxes.forEach(function(checkbox) {
				checkbox.checked = false;
			});
        });



		// initialize export dropdown
		document.getElementById("export").selectedIndex = 0;
		document.getElementById("export").addEventListener("change", function (event) {
			const filetype = event.target.value;
			console.log(filetype);
			document.getElementById("export").selectedIndex = 0;
			Print(filetype)
        });




		var coll = document.getElementsByClassName("weitere-layer");
		var i;

		for (i = 0; i < coll.length; i++) {
			coll[i].addEventListener("click", function() {
				var content = this.nextElementSibling;
				if (content.style.maxHeight){
				content.style.maxHeight = null;
				} else {
				content.style.maxHeight = content.scrollHeight + "px";
				} 
			});
		}

	}

	function openTab(evt) {
		if(evt.target.closest(".tab").className != "tab active") // if the tab clicked is not the currently active one...
		{
			$(".tab").removeClass("active"); // set clicked tab active
			$(evt.target.closest(".tab")).addClass("active")
			$("#measures").hide(); // switch measures and bottlenecks visibility
			$("#bottlenecks").hide();
			$("#strategies").hide();

			switch($(evt.target.closest(".tab")).attr('id')) {
				case "tab-measures":
					$("#measures").show();
					break;
				case "tab-bottlenecks":
					$("#bottlenecks").show();
					break;
				case "tab-strategies":
					$("#strategies").show();
					break;
				default:
					console.log("Unreachable: " + $(evt.target.closest(".tab")).attr('id'));
				} 
		}
	}

	function loadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image(100, 100);
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = url;
        });
    }

	// Sets the state of the checkboxes in the bottlenecks groups according to the checkbox of the bottlenecks tab
	function toggleBottleneckLayer() {

		let main = $('#tab-bottlenecks :input[type="checkbox"]');
		let isChecked = main.prop('checked');
		if (isChecked)
		{
			// $('#bottlenecks').find('input:checkbox:not(:checked)').trigger('click');
			$('#bottlenecks')
				.find('input:checkbox:not(:checked)')
				.filter(function () {
					return $(this)
					.parent()
					.parent()
					.attr('data-category') !== 'Zurückgestellte Problemstellen';
				})
				.trigger('click');
		}
		else
		{
			$('#bottlenecks').find('input:checkbox:checked').trigger('click');
		}

		filterBottlenecks(map);
	}

	function toggleMeasuresLayer() {
		let main = $('#tab-measures :input[type="checkbox"]');
		let isChecked = main.prop('checked');
		if (isChecked)
		{
			main.parent().parent().siblings("#measures").find('input:checkbox:not(:checked)').trigger('click');
		}
		else
		{
			main.parent().parent().siblings("#measures").find('input:checkbox:checked').trigger('click');
		}
	}

	function toggleStrategiesLayer() {
		let main = $('#tab-strategies :input[type="checkbox"]');
		let isChecked = main.prop('checked');
		var elements
		if (isChecked)
		{
			// uncheck all
			elements = main.parent().parent().siblings("#strategies").find('input:checkbox:checked')
			if (elements)
				elements.trigger('click');

			//Check only first 
			elements = main.parent().parent().siblings("#strategies").find('input:checkbox')[0]
			if (elements)
				elements.click()
		}
		else
		{
			var elements = main.parent().parent().siblings("#strategies").find('input:checkbox:checked')
			if(elements)
				elements.trigger('click');
		}
	}

	window.switchlayer = switchlayer;
	function switchlayer (layers, checkboxId) {
	for(var layer of layers)
	{
		console.log("Switching");
            if (document.getElementById(checkboxId).checked) {
                map.setLayoutProperty(layer, 'visibility', 'visible');
            } else {
                map.setLayoutProperty(layer, 'visibility', 'none');
           }
		}
        }

	$('#generate-btn').click(function() {
		console.log("printing...");
		Print()
  }); 

  

function handleMapClicks(){
	map.on('click', (e) => { // topmost layer
		const features = map.queryRenderedFeatures(e.point);
		// If no features are found, return early
		if (features.length == 0)
			return;
		
		const topmostFeature = features[0];
		const layerId = topmostFeature.layer.id;
		console.log("Clicked " + layerId);
		let txt = ''
		switch(layerId) {
			case 'landkreise-fill':
			case 'RadNETZBW-layer':
			case 'RadNETZKreis-layer':
			case 'RadNETZKom-layer':
			case 'RadOSM-layer':
			case 'bikeSharingStations':
			case 'Scooter-Leihstationen':
			case 'Fahrradabstellanlagen':
			case 'BAB-line':
			case 'BAB-name-label':
			case 'km-label':
			case 'km-symbol':
			case 'parking-sites':
			case 'dwista-layer':
			case 'lsa-layer':
			case 'lsa-osm-layer':
			case 'layer-car-sharing':

				Object.keys(topmostFeature.properties).forEach(function(key) {
					txt = txt + key + ': ' + topmostFeature.properties[key] + "<br />"
				})
				console.log(e.lngLat)

					//.setLngLat(turf.center(topmostFeature).geometry.coordinates)
					    // Get the clicked point
				var clickedPoint = e.lngLat;			
				// Convert clicked geographical coordinates to screen coordinates
				var clickedPointPixels = map.project(clickedPoint);			
				// Apply the pixel offset (move 50 pixels up)
				var offsetPixels = new maplibregl.Point(clickedPointPixels.x, clickedPointPixels.y - 20);
				
				// Convert the new screen coordinates back to geographical coordinates
				var newLngLat = map.unproject(offsetPixels);

				new maplibregl.Popup()	
					.setLngLat(e.lngLat)
					.setHTML(txt)
					.addTo(map)

				break;
			case 'K-line':
			case 'K-direction-arrow':
			case 'L-line':
			case 'L-direction-arrow':
			case 'B-line':
			case 'B-direction-arrow':


			// Find the nearest point on the line
			let clickPoint = [e.lngLat.lng, e.lngLat.lat]
			let featureId = topmostFeature.id
			console.log(featureId)
			let sourceFeature = data_streets.features[featureId]
			// Extract the sliced line from start to snapped point
			const slicedLine = turf.lineSlice(sourceFeature.geometry.coordinates[0], clickPoint, sourceFeature);

			// Get the length of the sliced line
			const lengthUpToPoint = Math.round(turf.length(slicedLine, { units: 'meters' }));

			console.log('Length up to Point (km):', lengthUpToPoint);
				Object.keys(topmostFeature.properties).forEach(function(key) {
						txt = txt + key + ': ' + topmostFeature.properties[key] + "<br />"
					})

				txt = txt + 'Anfangsnetzknoten: ' + topmostFeature.properties['Anfangsnetzknoten'].slice(-3) + "<br />"	
				txt = txt + 'Strecke ab Anfangsnetzknoten: ' + lengthUpToPoint + " m<br />"
				new maplibregl.Popup()	
						.setLngLat(e.lngLat)
						.setHTML(txt)
						.addTo(map)
				break

			case 'layer-problemstellen-fill':
				console.log("Problemstelle angeklickt");
				console.log(topmostFeature.properties.id)
				// ID comes from the geojson.
				let id = topmostFeature.properties.id 
				// check which layer is active
				if($('#tab-strategies :input[type="checkbox"]').prop('checked'))
				{
					$("#tab-strategies").click();
					let sidebarEntry = document.getElementById("strategy-bottleneck-entry-"+id)
					scrollSidebarToEntry(sidebarEntry);		
				}
				if($('#tab-bottlenecks :input[type="checkbox"]').prop('checked'))
				{
					$("#tab-bottlenecks").click();
					let sidebarEntry = document.getElementById("Problemstelle-" + id)
					scrollSidebarToEntry(sidebarEntry);		
				}

				break;
			case 'bus-labels':
			case 'bus-lines':
				var ref = topmostFeature.properties.ref
				txt = 'In diesem Abschnitt fahren die Buslinien:<br />' + ref
				new maplibregl.Popup()	
					.setLngLat(e.lngLat)
					.setHTML(txt)
					.addTo(map)

				break;

			case 'stadtbahn-labels':
			case 'stadtbahn-lines':
				var ref = topmostFeature.properties.ref
				txt = 'In diesem Abschnitt fahren die Stadtbahnlinien:<br />' + ref
				new maplibregl.Popup()	
					.setLngLat(e.lngLat)
					.setHTML(txt)
					.addTo(map)
				break;

			case 'zug-labels':
			case 'zug-lines':
				var ref = topmostFeature.properties.ref
				txt = 'In diesem Abschnitt fahren die Zuglinien:<br />' + ref
				new maplibregl.Popup()	
					.setLngLat(e.lngLat)
					.setHTML(txt)
					.addTo(map)
				break;

			case 'haltestellen-outlines':
			case 'haltestellen-fill':
				var l = topmostFeature.properties.l
				var n = topmostFeature.properties.n
				l = l.replace(/[{}']/g, "");
				txt = n + '<br />Diese Haltestelle wird von folgenden Linien bedient:<br />' + l
				new maplibregl.Popup()	
					.setLngLat(e.lngLat)
					.setHTML(txt)
					.addTo(map)
				break;
			case 'layer-Mobilitätsstationen':
				txt = "Mobilstation:<br>Dieser Bereich stellt einen multimodalen Knoten dar, von dem aus mindestens drei verschiedene Mobilitätsformen fußläufig (Entfernung unter 100 Meter) erreicht werden können.";
				new maplibregl.Popup()	
					.setLngLat(e.lngLat)
					.setHTML(txt)
					.addTo(map);
				break;
			default:
				console.log("Anderer layer angeklickt");
		} 
});
}

function handleHovering(){
	let hoveredFeatureId = null;
	let lastHoveredFeatureId = null;
	let lastHoveredLayerId = null;
	let lastHoveredFeature = null;

	let currentFeature = null;
	let currentLayerId = null;

        map.on('mousemove', (e) => {		
			const features = map.queryRenderedFeatures(e.point);

			if (features.length == 0)
				return;

			currentFeature = features[0];
			currentLayerId = currentFeature.layer.id;
			for(let i = 0; i<3; i++)
			{
				if(!(["landkreise-fill", "layer-problemstellen-fill"].includes(currentLayerId)))
				{
					if(features[i+1])
					{
					currentFeature = features[i+1]
					currentLayerId = currentFeature.layer.id;
					}

				}
				else break;
				if(i >= 2)
				{
					if(lastHoveredFeature)
					map.setFeatureState(
							{source: lastHoveredFeature.source, id: lastHoveredFeatureId},
							{hover: false}
						);
						return;
				}
			}

			
			let currentFeatureId = currentFeature.id;
			


			if(lastHoveredFeature)
			map.setFeatureState(
							{source: lastHoveredFeature.source, id: lastHoveredFeatureId},
							{hover: false}
						);
			if(!window.cursorOnMarker)
			map.setFeatureState(
							{source: currentFeature.source, id: currentFeatureId},
							{hover: true}
						);

			lastHoveredFeatureId = currentFeatureId;
			lastHoveredLayerId = currentLayerId;
			lastHoveredFeature = currentFeature;

		});
		map.on('mouseleave', 'landkreise-fill', () => {
            if (lastHoveredFeatureId) {
                map.setFeatureState(
                    {source: lastHoveredFeature.source, id: lastHoveredFeatureId},
                    {hover: false}
                );
            }
            hoveredFeatureId = null;
        });
}

const checkboxes = document.querySelectorAll('input[type="checkbox"]');

function setSvgAsBackground(svgUrl) {
	console.log("Loading image")
    // Fetch the SVG file content
    fetch(svgUrl)
        .then(response => response.text()) // Convert the response to text (SVG XML)
        .then(svgText => {
            // Optional: You can modify the SVG XML here if needed
            // For example, you could change the color, add classes, etc.

            // Encode the SVG content as a data URL
            const encodedData = encodeURIComponent(svgText);
            const dataUrl = `data:image/svg+xml;charset=utf-8,${encodedData}`;

            // Set the backgroundImage to the encoded data URL
            return `url(${dataUrl})`;
        })
        .catch(error => {
            console.error("Error loading SVG:", error);
        });
}

window.jsPDF = window.jspdf.jsPDF
function Print(format) {
    if (format == 'png') {
		html2canvas(document.getElementById('map'), 
		{
			ignoreElements: function( element ) {			
				if( 'map-buttons-container' == element.id ) {
					return true;
				}		
			}
		})
		.then(function(canvas) {
			canvas.toBlob(function(blob) {
                saveAs(blob, 'map.png');
            });;
		});



    } else if (format == 'pdf') {

			html2canvas(document.getElementById('map'), {
                ignoreElements: function (element) {
                    // Ignore specific elements by ID
                    if (element.id === 'map-buttons-container') {
                        return true;
                    }
                }
            }).then(canvas => {
                // Get the canvas as an image
                const imgData = canvas.toDataURL("image/png");

                // Use jsPDF to create a PDF
                const { jsPDF } = window.jspdf; // Access jsPDF from the global window object
                const pdf = new jsPDF();

                // Add the image to the PDF (fit it to the page)
                const imgWidth = 190; // Adjust width to fit the page (A4 is 210mm wide minus margins)
                const pageHeight = pdf.internal.pageSize.height;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;

                pdf.addImage(imgData, "PNG", 10, 10, imgWidth, imgHeight);

                // Save the PDF
                pdf.save("map.pdf");
            });

        }
	
}

function handlePointer()
{
	const layers = ['bus-lines', 'bus-labels', 'stadtbahn-lines', 'stadtbahn-labels', 'zug-lines', 'zug-labels', 'haltestellen-outlines', 'haltestellen-outlines', 'layer-Mobilitätsstationen',
					'RadNETZBW-layer', 'RadNETZKreis-layer', 'RadNETZKom-layer', 'RadOSM-layer', 'bikeSharingStations', 'Scooter-Leihstationen',
					'Fahrradabstellanlagen',
					'K-line', 'K-direction-arrow', 'L-line', 'L-direction-arrow', 'B-line', 'B-direction-arrow', 'BAB-line', 'BAB-name-label', 'km-label', 'km-symbol', 'parking-sites', 'dwista-layer', 'lsa-layer', 'lsa-osm-layer', 'layer-car-sharing']; // Array of layers to apply the effect

	layers.forEach(layer => {
		map.on('mouseenter', layer, () => {
			map.getCanvas().style.cursor = 'pointer';
		});

		map.on('mouseleave', layer, () => {
			map.getCanvas().style.cursor = '';
		});
	});
}


</script>
</body>
</html>